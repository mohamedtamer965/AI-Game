<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Drifter: Offline Mode</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-size: 24px;
            font-weight: bold;
        }

        .hud-bottom {
            padding: 20px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            text-align: center;
            font-size: 14px;
            opacity: 0.8;
        }

        #score-display span {
            color: #ffffff;
        }

        #shield-bar-container {
            width: 200px;
            height: 20px;
            border: 2px solid #00ffff;
            background: rgba(0, 0, 0, 0.5);
            transform: skewX(-20deg);
        }

        #shield-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            box-shadow: 0 0 15px #00ffff;
            transition: width 0.1s;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 0, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            z-index: 10;
            transition: opacity 0.5s;
        }

        h1 {
            color: #ffffff;
            font-size: 60px;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            letter-spacing: 10px;
            text-shadow: 4px 4px 0px #ff00ff, -4px -4px 0px #00ffff;
            animation: glitch 1s infinite alternate;
        }

        p {
            color: #ccc;
            font-size: 18px;
            margin-bottom: 40px;
            max-width: 600px;
            text-align: center;
            line-height: 1.5;
        }

        button {
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 40px;
            font-size: 24px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            box-shadow: 0 0 10px #00ffff;
        }

        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }
        
        button:disabled {
            border-color: #555;
            color: #555;
            box-shadow: none;
            cursor: not-allowed;
        }

        .hidden {
            display: none !important;
        }
        
        .fade-out {
            opacity: 0;
            pointer-events: none;
        }

        /* Loading indicator */
        #loading-msg {
            color: #00ffff;
            font-size: 16px;
            margin-top: 20px;
            font-weight: bold;
            height: 20px; /* Preserve space */
        }

        /* Local Upload Styles */
        .upload-section {
            margin-top: 20px;
            border-top: 1px solid #333;
            padding-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .upload-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        /* Custom File Input Styling */
        .custom-file-input {
            display: none;
        }
        
        .file-btn {
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            border: 1px dashed #00ffff;
            padding: 8px 15px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
            width: 200px;
            text-align: center;
        }
        
        .file-btn:hover {
            background: rgba(0, 255, 255, 0.3);
        }

        @keyframes glitch {
            0% { text-shadow: 4px 4px 0px #ff00ff, -4px -4px 0px #00ffff; }
            25% { text-shadow: -4px 4px 0px #ff00ff, 4px -4px 0px #00ffff; }
            50% { text-shadow: 4px -4px 0px #ff00ff, -4px 4px 0px #00ffff; }
            75% { text-shadow: -4px -4px 0px #ff00ff, 4px 4px 0px #00ffff; }
            100% { text-shadow: 4px 4px 0px #ff00ff, -4px -4px 0px #00ffff; }
        }
        
        .key { display: inline-block; border: 1px solid #fff; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; }
    </style>
    
    <!-- === OFFLINE LIBRARIES === -->
    <!-- These now point to the files in your folder, NOT the internet -->
    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>

</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">DISTANCE: <span id="score-val">0</span>km</div>
            <div id="shield-container">
                SHIELD
                <div id="shield-bar-container">
                    <div id="shield-bar"></div>
                </div>
            </div>
        </div>
        <div class="hud-bottom">
            SPEED: <span id="speed-val">100</span>%
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>Quantum Drifter</h1>
        <p>Pilot your craft through the unstable quantum tunnel.</p>
        <p>
            <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> or Arrows to Steer<br>
            Hold <span class="key">SPACE</span> to Boost
        </p>
        <button id="start-btn">Initialize System</button>
        <div id="loading-msg"></div>

        <!-- NEW: Local Upload Section -->
        <div class="upload-section">
            <span class="upload-label">Optional: Load Custom Models (.glb)</span>
            
            <label class="file-btn">
                Select Ship File
                <input type="file" id="upload-ship" class="custom-file-input" accept=".glb,.gltf">
            </label>
            
            <label class="file-btn">
                Select Obstacle File
                <input type="file" id="upload-obstacle" class="custom-file-input" accept=".glb,.gltf">
            </label>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #ff4444; text-shadow: 4px 4px 0 #550000;">CRITICAL FAILURE</h1>
        <p>Hull Integrity Compromised.</p>
        <p id="final-score" style="font-size: 24px; color: #fff;">Distance: 0km</p>
        <button id="restart-btn">Reboot System</button>
    </div>

    <script>
        // Check if library loaded
        if (typeof THREE === 'undefined') {
            document.getElementById('loading-msg').innerText = "ERROR: 'three.min.js' missing. Ensure it's in the same folder.";
            document.getElementById('loading-msg').style.color = "red";
        }

        // --- ASSET CONFIGURATION ---
        const MODEL_SCALES = {
            player: 2.5, 
            obstacle: 1.0 
        };

        // --- GAME VARIABLES ---
        let scene, camera, renderer, loader;
        let player, playerMeshGroup;
        
        // Object Pooling Variables
        let obstaclePool = [];
        let activeObstacles = [];
        const MAX_OBSTACLES = 20; // Maximum UFOs allowed (Performance Limit)
        
        let collectibles = [];
        let gameActive = false;
        let score = 0;
        let speed = 1.0;
        let baseSpeed = 0.8;
        let boostSpeed = 2.0;
        let shield = 100;

        let loadedTemplates = { obstacle: null };

        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, s: false, a: false, d: false, " ": false
        };

        const playerSpeed = 0.4;
        const playerFriction = 0.92;
        const playerVelocity = new THREE.Vector2(0, 0);
        const maxPos = { x: 18, y: 10 };

        const COLOR_BG = 0x050011;
        const COLOR_SHIP = 0x00ffff;
        const COLOR_OBSTACLE = 0xff2222;
        const COLOR_ENERGY = 0x0088ff;

        function init() {
            // Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLOR_BG);
            scene.fog = new THREE.FogExp2(COLOR_BG, 0.035);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 10);
            camera.lookAt(0, 0, -10);

            // Renderer Optimization: turned off physicallyCorrectLights for performance
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for speed
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Simple high-performance lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Init Loader for Local Uploads
            loader = new THREE.GLTFLoader();
            
            // Initial Objects (Procedural)
            createPlayer();
            initObstaclePool();
            createEnvironment();
            
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));

            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', resetGame);

            // File Upload Listeners
            document.getElementById('upload-ship').addEventListener('change', handleShipUpload);
            document.getElementById('upload-obstacle').addEventListener('change', handleObstacleUpload);

            animate();
        }

        // --- NEW: Handle Local Uploads ---
        function handleShipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            document.getElementById('loading-msg').innerText = "Processing Local Ship...";

            loader.load(url, (gltf) => {
                const model = gltf.scene;
                
                // Reuse existing normalization logic
                model.traverse(child => { if(child.isMesh) child.frustumCulled = true; });

                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                // Recalculate scale based on new model size
                const scaleFactor = (2.0 / Math.max(size.x, size.y, size.z)) * MODEL_SCALES.player;
                model.scale.set(scaleFactor, scaleFactor, scaleFactor);
                
                model.rotation.y = Math.PI; 
                model.rotation.z = Math.PI;

                playerMeshGroup.clear();
                playerMeshGroup.add(model);
                
                document.getElementById('loading-msg').innerText = "Local Ship Loaded!";
                event.target.parentElement.style.borderColor = "#00ff00";
                event.target.parentElement.childNodes[0].textContent = "Ship Ready: " + file.name.substring(0, 10) + "...";
            }, undefined, (err) => {
                console.error(err);
                document.getElementById('loading-msg').innerText = "Error Loading File";
            });
        }

        function handleObstacleUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            document.getElementById('loading-msg').innerText = "Processing Local Obstacle...";

            loader.load(url, (gltf) => {
                loadedTemplates.obstacle = gltf.scene;
                loadedTemplates.obstacle.rotation.z = Math.PI;
                
                loadedTemplates.obstacle.traverse(child => { if(child.isMesh) child.frustumCulled = true; });

                // CRITICAL: We must rebuild the pool because the old models are already baked
                rebuildObstaclePool();

                document.getElementById('loading-msg').innerText = "Local Obstacles Ready!";
                event.target.parentElement.style.borderColor = "#00ff00";
                event.target.parentElement.childNodes[0].textContent = "UFO Ready: " + file.name.substring(0, 10) + "...";
            }, undefined, (err) => {
                console.error(err);
                document.getElementById('loading-msg').innerText = "Error Loading File";
            });
        }

        function rebuildObstaclePool() {
            // 1. Remove all existing pool meshes from scene
            obstaclePool.forEach(mesh => scene.remove(mesh));
            activeObstacles.forEach(mesh => scene.remove(mesh));
            
            // 2. Clear arrays
            obstaclePool = [];
            activeObstacles = [];
            
            // 3. Re-create using the new template
            initObstaclePool();
        }

        // --- OBJECT POOLING SYSTEM ---
        function initObstaclePool() {
            // If model didn't load, use placeholder geometry
            let geometry, material, mesh;
            
            if (!loadedTemplates.obstacle) {
                // Fallback / Default
                geometry = new THREE.TetrahedronGeometry(1.0);
                material = new THREE.MeshStandardMaterial({ 
                    color: COLOR_OBSTACLE,
                    emissive: 0x550000,
                    roughness: 0.6,
                    flatShading: true
                });
            }

            for(let i=0; i<MAX_OBSTACLES; i++) {
                if (loadedTemplates.obstacle) {
                    mesh = loadedTemplates.obstacle.clone();
                    // Fix scale for pooled objects
                    const box = new THREE.Box3().setFromObject(mesh);
                    const size = box.getSize(new THREE.Vector3());
                    const normalizeScale = 1.5 / Math.max(size.x, size.y, size.z); 
                    mesh.scale.set(normalizeScale, normalizeScale, normalizeScale);
                } else {
                    mesh = new THREE.Mesh(geometry, material);
                }
                
                mesh.visible = false;
                mesh.position.set(0, 0, -500); // Hide far away
                mesh.userData = { active: false, radius: 1.0 };
                
                scene.add(mesh);
                obstaclePool.push(mesh);
            }
        }

        function getObstacleFromPool() {
            // Find first inactive object
            for(let i=0; i<obstaclePool.length; i++) {
                if(!obstaclePool[i].userData.active) {
                    return obstaclePool[i];
                }
            }
            return null; // Pool exhausted
        }

        function createPlayer() {
            player = new THREE.Group();
            playerMeshGroup = new THREE.Group();

            // Default procedural ship
            const geometry = new THREE.ConeGeometry(0.5, 2, 4);
            const material = new THREE.MeshStandardMaterial({ 
                color: COLOR_SHIP, emissive: 0x0044aa, emissiveIntensity: 0.5,
                roughness: 0.2, metalness: 0.8, flatShading: true
            });
            const body = new THREE.Mesh(geometry, material);
            body.rotation.x = -Math.PI / 2;
            
            // Simple Wings
            const wingGeom = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                0, 0, 0.5, 1.5, 0, -1, 0, 0, -1,
                0, 0, 0.5, -1.5, 0, -1, 0, 0, -1
            ]);
            wingGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            const wingMat = new THREE.MeshStandardMaterial({ color: 0x0088aa, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
            const wings = new THREE.Mesh(wingGeom, wingMat);

            playerMeshGroup.add(body);
            playerMeshGroup.add(wings);

            player.add(playerMeshGroup);
            scene.add(player);
        }

        function createEnvironment() {
            const gridHelper = new THREE.GridHelper(100, 40, 0xff00ff, 0x220044);
            gridHelper.position.y = -5;
            gridHelper.position.z = -20;
            gridHelper.scale.z = 5;
            scene.add(gridHelper);
            scene.userData.grid = gridHelper;
        }

        function handleKey(e, isDown) {
            if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) {
                keys[e.key] = isDown;
                if(e.code === "Space") keys[" "] = isDown;
            }
        }

        function spawnObstacle() {
            const mesh = getObstacleFromPool();
            if(!mesh) return; // No objects available in pool

            // Reset Object State
            mesh.userData.active = true;
            mesh.visible = true;
            mesh.position.x = (Math.random() - 0.5) * 30;
            mesh.position.y = (Math.random() - 0.5) * 16;
            mesh.position.z = -80;
            
            // Random rotations
            mesh.userData.rotX = Math.random() * 0.05;
            mesh.userData.rotY = Math.random() * 0.05;

            activeObstacles.push(mesh);
        }

        function spawnCollectible() {
            // Collectibles are simple, we can just create/destroy or pool them too. 
            // For now, keeping them simple as they are just wireframes.
            const geometry = new THREE.IcosahedronGeometry(0.4, 0);
            const material = new THREE.MeshBasicMaterial({ color: COLOR_ENERGY, wireframe: true });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.x = (Math.random() - 0.5) * 25;
            mesh.position.y = (Math.random() - 0.5) * 14;
            mesh.position.z = -80;

            const coreGeom = new THREE.SphereGeometry(0.2, 4, 4);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const core = new THREE.Mesh(coreGeom, coreMat);
            mesh.add(core);

            mesh.userData = { type: 'energy', radius: 0.5 };
            scene.add(mesh);
            collectibles.push(mesh);
        }

        function startGame() {
            score = 0;
            shield = 100;
            gameActive = true;
            player.position.set(0, 0, 0);
            playerVelocity.set(0, 0);
            
            // Deactivate all obstacles
            activeObstacles.forEach(o => {
                o.visible = false;
                o.userData.active = false;
                o.position.z = -500;
            });
            activeObstacles = [];

            // Remove collectibles
            collectibles.forEach(c => scene.remove(c));
            collectibles = [];

            document.getElementById('start-screen').classList.add('fade-out');
            document.getElementById('game-over-screen').classList.add('hidden');
            updateHUD();
        }

        function resetGame() {
            startGame();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePhysics() {
            if (!gameActive) return;

            // Player Movement
            let inputX = 0, inputY = 0;
            if (keys.ArrowUp || keys.w) inputY += 1;
            if (keys.ArrowDown || keys.s) inputY -= 1;
            if (keys.ArrowLeft || keys.a) inputX -= 1;
            if (keys.ArrowRight || keys.d) inputX += 1;

            playerVelocity.x += inputX * playerSpeed * 0.1;
            playerVelocity.y += inputY * playerSpeed * 0.1;
            playerVelocity.multiplyScalar(playerFriction);
            player.position.x += playerVelocity.x;
            player.position.y += playerVelocity.y;

            if (player.position.x > maxPos.x) { player.position.x = maxPos.x; playerVelocity.x *= -0.5; }
            if (player.position.x < -maxPos.x) { player.position.x = -maxPos.x; playerVelocity.x *= -0.5; }
            if (player.position.y > maxPos.y) { player.position.y = maxPos.y; playerVelocity.y *= -0.5; }
            if (player.position.y < -maxPos.y) { player.position.y = -maxPos.y; playerVelocity.y *= -0.5; }

            // Tilt
            playerMeshGroup.rotation.z = -playerVelocity.x * 0.5; 
            playerMeshGroup.rotation.x = (playerVelocity.y * 0.2); 

            // Speed & Spawning
            const isBoosting = keys[" "] || keys["Space"];
            const targetSpeed = isBoosting ? boostSpeed : baseSpeed;
            speed += (targetSpeed - speed) * 0.05;
            const moveSpeed = speed * 0.8;

            if (Math.random() < 0.05 * speed) spawnObstacle();
            if (Math.random() < 0.02) spawnCollectible();

            // Environment
            if (scene.userData.grid) {
                scene.userData.grid.position.z += moveSpeed;
                if (scene.userData.grid.position.z > 0) scene.userData.grid.position.z = -20;
            }

            // Update Active Obstacles (Pooling Logic)
            for (let i = activeObstacles.length - 1; i >= 0; i--) {
                const obj = activeObstacles[i];
                obj.position.z += moveSpeed;
                
                // Rotation
                if(obj.userData.rotX) {
                    obj.rotation.x += obj.userData.rotX;
                    obj.rotation.y += obj.userData.rotY;
                }

                // Collision
                if (obj.position.z > -5 && obj.position.z < 5) {
                    const dist = player.position.distanceTo(obj.position);
                    if (dist < obj.userData.radius + 0.5) {
                        takeDamage(34);
                        // Return to pool immediately on hit
                        deactivateObstacle(obj, i);
                        continue;
                    }
                }
                
                // Passed player
                if (obj.position.z > 10) {
                    deactivateObstacle(obj, i);
                }
            }

            // Update Collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const obj = collectibles[i];
                obj.position.z += moveSpeed;
                obj.rotation.y += 0.05;
                if (obj.position.z > -5 && obj.position.z < 5) {
                    const dist = player.position.distanceTo(obj.position);
                    if (dist < obj.userData.radius + 0.8) {
                        collectEnergy();
                        removeCollectible(obj, i);
                        continue;
                    }
                }
                if (obj.position.z > 10) removeCollectible(obj, i);
            }

            score += speed * 0.1;
            updateHUD();
        }

        function deactivateObstacle(obj, index) {
            obj.visible = false;
            obj.userData.active = false;
            obj.position.z = -500; // Move safely away
            activeObstacles.splice(index, 1);
        }

        function removeCollectible(obj, index) {
            scene.remove(obj);
            obj.geometry.dispose();
            obj.material.dispose();
            collectibles.splice(index, 1);
        }

        function takeDamage(amount) {
            shield -= amount;
            camera.position.x = (Math.random() - 0.5) * 1;
            camera.position.y = 2 + (Math.random() - 0.5) * 1;
            document.getElementById('ui-layer').style.boxShadow = "inset 0 0 50px rgba(255,0,0,0.5)";
            setTimeout(() => {
                document.getElementById('ui-layer').style.boxShadow = "none";
                camera.position.set(0, 2, 10);
            }, 100);
            if (shield <= 0) gameOver();
        }

        function collectEnergy() {
            shield = Math.min(shield + 15, 100);
            score += 100;
        }

        function updateHUD() {
            document.getElementById('score-val').innerText = Math.floor(score);
            document.getElementById('speed-val').innerText = Math.floor(speed * 100);
            document.getElementById('shield-bar').style.width = Math.max(0, shield) + "%";
            const bar = document.getElementById('shield-bar');
            if(shield < 30) bar.style.background = "#ff0000";
            else if (shield < 60) bar.style.background = "#ffaa00";
            else bar.style.background = "linear-gradient(90deg, #00ffff, #0088ff)";
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = `Total Distance: ${Math.floor(score)}km`;
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        window.onload = init;

    </script>
</body>
</html>